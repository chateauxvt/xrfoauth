/**
* XRF OAuth2
* XRF OAuth2 Authorization server for generating access tokens to xApps 
*
* The version of the OpenAPI document: 1
* Contact: tolgaoa@vt.edu
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "pistache/endpoint.h"
#include "pistache/http.h"
#include "pistache/router.h"
#ifdef __linux__
#include <vector>
#include <signal.h>
#include <unistd.h>
#endif

#include "AccessTokenRequestApiImpl.h"
#include "xrf-api-server.h"

#define PISTACHE_SERVER_THREADS     2
#define PISTACHE_SERVER_MAX_REQUEST_SIZE 32768
#define PISTACHE_SERVER_MAX_RESPONSE_SIZE 32768
#define PISTACHE_SERVER_MAX_PAYLOAD 32768

static Pistache::Http::Endpoint *httpEndpoint;
#ifdef __linux__
static void sigHandler [[noreturn]] (int sig){
    switch(sig){
        case SIGINT:
        case SIGQUIT:
        case SIGTERM:
        case SIGHUP:
        default:
            httpEndpoint->shutdown();//can change default to nothing later
            break;
    }
    exit(0);
}

static void setUpUnixSignals(std::vector<int> quitSignals) {
    sigset_t blocking_mask;
    sigemptyset(&blocking_mask);
    for (auto sig : quitSignals)
        sigaddset(&blocking_mask, sig);

    struct sigaction sa;
    sa.sa_handler = sigHandler;
    sa.sa_mask    = blocking_mask;
    sa.sa_flags   = 0;

    for (auto sig : quitSignals)
        sigaction(sig, &sa, nullptr);
}
#endif

using namespace xrf::api;
using namespace xrf::app;

XRFApiServer::XRFApiServer(Pistache::Address addr, xrf_main* xrf_main_inst)
: m_httpEndpoint(std::make_shared<Pistache::Http::Endpoint>(addr)) {
	m_router  = std::make_shared<Pistache::Rest::Router>();
	m_address = addr.host() + ":" + (addr.port()).toString();

	/* m_completeStoredSearchDocumentApiImpl =
	std::make_shared<CompleteStoredSearchDocumentApiImpl>(
	    m_router, nrf_app_inst, m_address);
	m_nfInstancesStoreApiImpl = std::make_shared<NFInstancesStoreApiImpl>(
	m_router, nrf_app_inst, m_address);
	m_storedSearchDocumentApiImpl =
	std::make_shared<StoredSearchDocumentApiImpl>(
	    m_router, nrf_app_inst, m_address);
	m_nfInstanceIDDocumentApiImpl =
	std::make_shared<NFInstanceIDDocumentApiImpl>(
	    m_router, nrf_app_inst, m_address);
	m_subscriptionIDDocumentApiImpl =
	std::make_shared<SubscriptionIDDocumentApiImpl>(
	    m_router, nrf_app_inst, m_address);
	m_subscriptionsCollectionApiImpl =
	std::make_shared<SubscriptionsCollectionApiImpl>(
	    m_router, nrf_app_inst, m_address);
	m_discNFInstancesStoreApiImpl =
	std::make_shared<DiscNFInstancesStoreApiImpl>(
	    m_router, nrf_app_inst, m_address);*/
	m_accessTokenRequestApiImpl = std::make_shared<AccessTokenRequestApiImpl>(
	    m_router, xrf_main_inst, m_address);

}

void XRFApiServer::init(size_t thr) {
  auto opts = Pistache::Http::Endpoint::options().threads(thr);
  opts.flags(Pistache::Tcp::Options::ReuseAddr);
  opts.maxRequestSize(PISTACHE_SERVER_MAX_PAYLOAD);
  m_httpEndpoint->init(opts);

  //m_completeStoredSearchDocumentApiImpl->init();
  //m_nfInstancesStoreApiImpl->init();
  //m_storedSearchDocumentApiImpl->init();
  //m_nfInstanceIDDocumentApiImpl->init();
  //m_subscriptionIDDocumentApiImpl->init();
  //m_subscriptionsCollectionApiImpl->init();
  //m_discNFInstancesStoreApiImpl->init();
  m_accessTokenRequestApiImpl->init();
}
void XRFApiServer::start() {
  m_httpEndpoint->setHandler(m_router->handler());
  m_httpEndpoint->serve();
}
void XRFApiServer::shutdown() {
  m_httpEndpoint->shutdown();
}


/*int main() {
#ifdef __linux__
    std::vector<int> sigs{SIGQUIT, SIGINT, SIGTERM, SIGHUP};
    setUpUnixSignals(sigs);
#endif
    Pistache::Address addr(Pistache::Ipv4::any(), Pistache::Port(8080));

    httpEndpoint = new Pistache::Http::Endpoint((addr));
    auto router = std::make_shared<Pistache::Rest::Router>();

    auto opts = Pistache::Http::Endpoint::options()
        .threads(PISTACHE_SERVER_THREADS);
    opts.flags(Pistache::Tcp::Options::ReuseAddr);
    opts.maxRequestSize(PISTACHE_SERVER_MAX_REQUEST_SIZE);
    opts.maxResponseSize(PISTACHE_SERVER_MAX_RESPONSE_SIZE);
    httpEndpoint->init(opts);

    
    AccessTokenRequestApiImpl AccessTokenRequestApiserver(router);
    AccessTokenRequestApiserver.init();

    httpEndpoint->setHandler(router->handler());
    httpEndpoint->serve();

    httpEndpoint->shutdown();

}*/
